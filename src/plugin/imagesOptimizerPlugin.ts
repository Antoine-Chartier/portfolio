// c:\Users\antoi\Local Sites\Portfolio\monPortfolio\src\plugin\imagesOptimizerPlugin.ts
import path, { basename, extname } from 'node:path';
import { Plugin } from 'vite';
import sharp from 'sharp';

// --- Constants ---
const OPTIMIZED_PATTERN = '?optimized';
const SHARP_HANDLER_QUERY_PREFIX = '?sharp_'; // Use a distinct prefix for internal handler
const WIDTH_PARAM = 'w';
const DEFAULT_WIDTHS = [480, 768, 1024]; // Default widths if 'w' not specified
const FALLBACK_FORMAT = 'png'; // Or 'jpeg'
const FALLBACK_QUALITY = 70;
const WEBP_QUALITY = 80;
const AVIF_QUALITY = 60; // Adjust quality as needed

const isProd = process.env.NODE_ENV === 'production';
// const isProd = true; // For testing production logic in dev

// --- Helper Functions ---

function parseQuery(id: string): URLSearchParams {
    const queryIndex = id.indexOf('?');
    return new URLSearchParams(queryIndex > -1 ? id.substring(queryIndex) : '');
}

function getRequestedWidths(query: URLSearchParams): number[] {
    const widthsParam = query.get(WIDTH_PARAM);
    if (widthsParam) {
        return widthsParam.split(';')
            .map(w => parseInt(w.trim(), 10))
            .filter(w => !isNaN(w) && w > 0)
            .sort((a, b) => a - b); // Sort widths numerically
    }
    return DEFAULT_WIDTHS;
}

function resolveBaseImagePath(id: string, importer: string | undefined): string | null {
    if (!importer) return null;
    const queryIndex = id.indexOf('?');
    const basePath = queryIndex > -1 ? id.substring(0, queryIndex) : id;
    return path.resolve(path.dirname(importer), basePath);
}

// --- Plugin Implementation ---

export const imageOptimizerPlugin = (): Plugin[] => {
    return [
        {
            // Handles individual format/size requests generated by ?optimized-handler
            name: 'sharp-internal-handler',
            enforce: 'pre',
            async resolveId(id, importer) {
                if (!id.includes(SHARP_HANDLER_QUERY_PREFIX)) return null;
                // Resolve the base file path relative to the importer, keep the query
                const basePath = resolveBaseImagePath(id, importer);
                if (!basePath) return null;
                return basePath + id.substring(id.indexOf('?'));
            },
            async load(id) {
                if (!id.includes(SHARP_HANDLER_QUERY_PREFIX)) return null;

                const query = parseQuery(id);
                const format = query.get('f'); // 'webp', 'avif', 'fallback'
                const width = parseInt(query.get('w') || '0', 10);
                const basePath = id.split('?')[0];

                if (!format || !width || !['webp', 'avif', 'fallback'].includes(format)) {
                    this.warn(`Invalid sharp request: ${id}`);
                    return null;
                }

                try {
                    let transformer = sharp(basePath);

                    // --- Resize Step ---
                    transformer = transformer.resize({ width: width }); // Resize first

                    // --- Format Conversion Step ---
                    let outputBuffer: Buffer;
                    let outputExtension: string;

                    if (format === 'fallback') {
                        outputBuffer = await transformer
                            .png({ quality: FALLBACK_QUALITY, effort: 7, compressionLevel: 6 }) // Or .jpeg()
                            .toBuffer();
                        outputExtension = FALLBACK_FORMAT;
                    } else if (format === 'webp') {
                        outputBuffer = await transformer.webp({ quality: WEBP_QUALITY }).toBuffer();
                        outputExtension = 'webp';
                    } else { // avif
                        outputBuffer = await transformer.avif({ quality: AVIF_QUALITY }).toBuffer();
                        outputExtension = 'avif';
                    }

                    // --- Emit File ---
                    const inputFilename = basename(basePath, extname(basePath));
                    // Include width and format hint in the output name for clarity
                    const outputName = `${inputFilename}-w${width}.${outputExtension}`;

                    const referenceId = this.emitFile({
                        type: 'asset',
                        name: outputName,
                        needsCodeReference: true, // Important for getting the URL
                        source: outputBuffer
                    });

                    // Return code that exports the URL of the generated asset
                    return `export default import.meta.ROLLUP_FILE_URL_${referenceId};`;

                } catch (error) {
                    console.error(`Error processing image ${basePath} for ${format} w${width}:`, error);
                    this.error(`Failed to process image ${basePath}: ${(error as Error).message}`);
                    return null;
                }
            }
        },
        {
            // Handles the initial "?optimized" import with optional "&w=..."
            name: 'optimized-handler',
            enforce: 'pre',
            async resolveId(id, importer) {
                if (!id?.includes(OPTIMIZED_PATTERN)) return null;
                // Resolve the base file path relative to the importer, keep the query
                const basePath = resolveBaseImagePath(id, importer);
                 if (!basePath) return null;
                return basePath + id.substring(id.indexOf('?'));
            },
            async load(id) {
                if (!id?.includes(OPTIMIZED_PATTERN)) return null;

                const basePath = id.split('?')[0];
                const query = parseQuery(id);

                // --- Development Mode ---
                if (!isProd) {
                    console.warn(`DEV MODE: Skipping optimization for ${basename(basePath)}. Serving original.`);
                    // Provide a structure consistent with production, but with original path
                    // Note: width/height might be inaccurate in dev without sharp metadata
                    return `
                        import fallback from "${basePath}";
                        export default {
                            sources: { avif: fallback + ' 1x', webp: fallback + ' 1x' },
                            img: { src: fallback, w: 0, h: 0 }
                        };`;
                }

                // --- Production Mode ---
                try {
                    const requestedWidths = getRequestedWidths(query);
                    const metadata = await sharp(basePath).metadata();
                    const originalWidth = metadata.width;
                    const originalHeight = metadata.height;

                    if (!originalWidth || !originalHeight) {
                        throw new Error(`Could not read metadata for ${basePath}`);
                    }

                    // Filter widths to not exceed original (optional, prevents upscaling)
                    const widthsToGenerate = requestedWidths.filter(w => w <= originalWidth);
                    // Ensure the original width is included if no requested widths are smaller
                    if (widthsToGenerate.length === 0 && requestedWidths.length > 0) {
                         widthsToGenerate.push(originalWidth);
                    } else if (!widthsToGenerate.includes(originalWidth) && requestedWidths.some(w => w > originalWidth)) {
                        // Add original width if some requested widths were larger
                        widthsToGenerate.push(originalWidth);
                        widthsToGenerate.sort((a, b) => a - b);
                    } else if (widthsToGenerate.length === 0) {
                        // If no widths requested and defaults are larger, use original
                         widthsToGenerate.push(originalWidth);
                    }


                    const imports: string[] = [];
                    const webpSources: string[] = [];
                    const avifSources: string[] = [];
                    const fallbackVars: { [width: number]: string } = {};

                    // Generate imports for each format and width
                    for (const width of widthsToGenerate) {
                        const webpVar = `webp_${width}`;
                        const avifVar = `avif_${width}`;
                        const fallbackVar = `fallback_${width}`;

                        // Use the internal handler prefix and specify format (f) and width (w)
                        const webpImportPath = `${basePath}${SHARP_HANDLER_QUERY_PREFIX}&f=webp&w=${width}`;
                        const avifImportPath = `${basePath}${SHARP_HANDLER_QUERY_PREFIX}&f=avif&w=${width}`;
                        const fallbackImportPath = `${basePath}${SHARP_HANDLER_QUERY_PREFIX}&f=fallback&w=${width}`;

                        imports.push(`import ${webpVar} from ${JSON.stringify(webpImportPath)};`);
                        imports.push(`import ${avifVar} from ${JSON.stringify(avifImportPath)};`);
                        imports.push(`import ${fallbackVar} from ${JSON.stringify(fallbackImportPath)};`);

                        // Store for srcset generation
                        webpSources.push(`\${${webpVar}} ${width}w`);
                        avifSources.push(`\${${avifVar}} ${width}w`);
                        fallbackVars[width] = fallbackVar; // Store fallback variable name by width
                    }

                    // Determine the src for the main <img> tag - use the largest generated fallback
                    const largestGeneratedWidth = Math.max(...widthsToGenerate);
                    const fallbackSrcVar = fallbackVars[largestGeneratedWidth] || '""'; // Default to empty string if no fallbacks generated

                    // Construct the final code
                    const importBlock = imports.join('\n');
                    const webpSrcset = webpSources.join(', ');
                    const avifSrcset = avifSources.join(', ');

                    const exportBlock = `
                        export default {
                            sources: {
                                avif: \`${avifSrcset}\`,
                                webp: \`${webpSrcset}\`
                            },
                            img: {
                                src: ${fallbackSrcVar},
                                w: ${originalWidth},
                                h: ${originalHeight}
                            }
                        };
                    `;

                    return `${importBlock}\n${exportBlock}`;

                } catch (error) {
                    console.error(`Error processing optimized request for ${basePath}:`, error);
                    this.error(`Failed to optimize image ${basePath}: ${(error as Error).message}`);
                    // Return a minimal structure to prevent build failure
                     return `export default { sources: { avif: '', webp: '' }, img: { src: '', w: 0, h: 0 } };`;
                }
            }
        }
    ];
};
